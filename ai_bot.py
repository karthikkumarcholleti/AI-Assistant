# -*- coding: utf-8 -*-
"""AI-bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FqaSW7wzWeVa83ddSh4jx8mUJ8WrseV7
"""

pip install dateparser



# I saved my model in my drive.

from google.colab import drive
drive.mount('/content/drive')

import spacy
import yfinance as yf
import dateparser
import re
import torch
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta
from transformers import BertTokenizer, BertForSequenceClassification

# Load spaCy model for date extraction
nlp = spacy.load("en_core_web_sm")

# Function to extract dates and time periods from queries
def extract_dates(query):
    query_lower = query.lower()
    regex_patterns = {
        "last week": "5d",
        "this week": "5d",
        "last month": "1mo",
        "this month": "1mo",
        "last year": "1y",
        "this year": "ytd",
        "year to date": "ytd",
        "three months": "3mo",
        "six months": "6mo",
        r"\d+ days? ago": "custom_days",
        r"\d+ weeks? ago": "custom_weeks",
        r"\d+ months? ago": "custom_months"
    }

    for pattern, period in regex_patterns.items():
        if re.search(pattern, query_lower):
            if period == "custom_days":
                days_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(days=days_ago), None
            elif period == "custom_weeks":
                weeks_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(weeks=weeks_ago), None
            elif period == "custom_months":
                months_ago = int(re.search(r"\d+", query_lower).group())
                return datetime.now() - timedelta(days=months_ago * 30), None
            return None, period

    doc = nlp(query)
    for ent in doc.ents:
        if ent.label_ == "DATE":
            return dateparser.parse(ent.text), None
    return dateparser.parse(query), None

# Known stock symbols for direct matching
known_symbols = ["TSLA", "AMZN", "MSFT", "GOOGL", "META", "AAPL", "AMD", "NVDA"]

# Function to extract company names or symbols
def extract_company_names(query):
    doc = nlp(query)
    companies = [ent.text for ent in doc.ents if ent.label_ == "ORG"]

    manual_corrections = {
        "Tesla": "TSLA",
        "Amazon": "AMZN",
        "Microsoft": "MSFT",
        "Google": "GOOGL",
        "Facebook": "META",
        "Apple": "AAPL"
    }

    detected_symbols = [word.upper() for word in query.split() if word.upper() in known_symbols]
    corrected_companies = [manual_corrections.get(company, company) for company in companies]
    return list(set(detected_symbols + corrected_companies))

# Function to predict class labels with confidence threshold
def predict_class(query, model, tokenizer, label_map, threshold=0.5):
    inputs = tokenizer(query, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)
    probs = torch.nn.functional.softmax(outputs.logits, dim=1)
    confidence, predicted_class = torch.max(probs, dim=1)
    if confidence.item() < threshold:
        print("Low confidence in prediction. Consider rephrasing the query.")
        return None
    return label_map.get(predicted_class.item(), None)

# Function to generate a trend summary
def generate_trend_summary(data, price_type, start_date, end_date):
    start_value = data.iloc[0]
    end_value = data.iloc[-1]
    percentage_change = ((end_value - start_value) / start_value) * 100

    if end_value > start_value:
        trend = "upward"
    elif end_value < start_value:
        trend = "downward"
    else:
        trend = "stable"

    return (f"The plot shows a {trend} trend from {start_date.strftime('%B %d, %Y')} to "
            f"{end_date.strftime('%B %d, %Y')} with a percentage change of {percentage_change:.2f}%.")

# Function to fetch stock data with error handling and specific date handling
def fetch_stock_data(stock_symbol, price_type, time_period=None, specific_date=None, for_trend=False):
    try:
        stock = yf.Ticker(stock_symbol)
        market_closed_message = ""

        if specific_date:
            original_date = specific_date
            start_date = specific_date
            end_date = specific_date + timedelta(days=1)
            historical_data = stock.history(start=start_date, end=end_date)

            while historical_data.empty and start_date > datetime(2000, 1, 1):
                start_date -= timedelta(days=1)
                end_date = start_date + timedelta(days=1)
                historical_data = stock.history(start=start_date, end=end_date)

            if start_date != original_date:
                market_closed_message = f"The market was closed on {original_date.strftime('%B %d, %Y')}. Displaying data from the nearest available trading day: {start_date.strftime('%B %d, %Y')}."

            if historical_data.empty:
                print(f"Error: No data found for {stock_symbol} on {specific_date}. Try a different date or time period.")
                return None

        else:
            historical_data = stock.history(period=time_period)

        if historical_data.empty:
            print(f"Error: No data found for {stock_symbol} on {specific_date or time_period}. Try a different date or time period.")
            return None

        if market_closed_message:
            print(market_closed_message)

        if for_trend:
            return historical_data[price_type.capitalize()] if price_type in ['open', 'close', 'high', 'low', 'volume'] else historical_data['Close']

        if price_type == "volume" and not specific_date:
            return historical_data['Volume'].mean()
        else:
            price_lookup = {
                "high": historical_data['High'].max,
                "low": historical_data['Low'].min,
                "open": lambda: historical_data['Open'].iloc[0],
                "close": lambda: historical_data['Close'].iloc[-1],
                "volume": lambda: historical_data['Volume'].iloc[-1] if specific_date else historical_data['Volume'].sum,
                "current": lambda: historical_data['Close'].iloc[-1]
            }

            return price_lookup[price_type]() if not historical_data.empty else None

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

# Visualization functions
# Visualization function with updated title for bar plot comparison
def plot_comparison(stock_data, stock_symbols, price_type):
    plt.figure(figsize=(10, 6))
    plt.bar(stock_symbols, stock_data)
    plt.title(f"Comparison of {price_type.capitalize()} Prices for {' and '.join(stock_symbols)}")
    plt.ylabel(f"{price_type.capitalize()} Price")
    plt.xlabel("Stocks")
    plt.show()


def plot_multiple_trends(stock_data_dict, price_type, time_period):
    main_title = f" Stock Price Movements over the period of {time_period.capitalize()}" if len(stock_data_dict) > 1 else f"{list(stock_data_dict.keys())[0]} Stock Price Movement ({time_period.capitalize()} Trend)"

    fig, axes = plt.subplots(len(stock_data_dict), 1, figsize=(10, 6 * len(stock_data_dict)), sharex=True)
    fig.suptitle(main_title, fontsize=16)

    if len(stock_data_dict) == 1:
        axes = [axes]

    for i, (symbol, data) in enumerate(stock_data_dict.items()):
        start_date = data.index[0]
        end_date = data.index[-1]
        axes[i].plot(data, label=f"{symbol} Price", color='tab:blue')
        axes[i].set_title(f"{symbol} Trend from {start_date.strftime('%B %d, %Y')} to {end_date.strftime('%B %d, %Y')}")
        axes[i].set_ylabel(f"{price_type.capitalize()} Price")
        axes[i].legend(loc="best")
        axes[i].grid(axis='y', linestyle='--', linewidth=0.5)
        trend_summary = generate_trend_summary(data, price_type, start_date, end_date)
        print(f"Summary for {symbol}: {trend_summary}")

    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()

def fetch_stock_summary(stock_symbol):
    stock = yf.Ticker(stock_symbol)
    info = stock.info
    return {
        "Name": info.get("shortName"),
        "Market Cap": info.get("marketCap"),
        "Sector": info.get("sector"),
        "Industry": info.get("industry"),
        "Country": info.get("country"),
        "Previous Close": info.get("previousClose"),
        "52 Week Range": (info.get("fiftyTwoWeekLow"), info.get("fiftyTwoWeekHigh")),
        "Open": info.get("open"),
        "Volume": info.get("volume"),
        "Avg Volume": info.get("averageVolume"),
        "Beta (5Y Monthly)": info.get("beta"),
        "PE Ratio (TTM)": info.get("trailingPE"),
        "EPS (TTM)": info.get("trailingEps"),
        "1y Target Est": info.get("targetMeanPrice")
    }
# Main query handling function
# Main query handling function
# Main query handling function
def handle_query(query):
    specific_date, time_period = extract_dates(query)
    company_names = extract_company_names(query)

    if company_names:
        stock_symbols = [company for company in company_names if company in known_symbols]

        if stock_symbols:
            print(f"Question: {query}")

            # Special handling for summaries
            if "summary" in query.lower() or "52 week range" in query.lower():
                for symbol in stock_symbols:
                    summary = fetch_stock_summary(symbol)
                    print(f"Answer: Summary for {symbol}: {summary}")
                return

            # Load models only once to avoid reloading per query
            intent_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')#path to your files
            intent_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')
            price_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
            price_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
            time_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')
            time_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')

            # Map intents, price types, and time periods
            intent_labels = {0: 'price_inquiry', 1: 'stock_comparison', 2: 'stock_trend', 3: 'summary'}
            price_labels = {0: 'low', 1: 'open', 2: 'high', 3: 'close', 4: 'volume', 5: 'current'}
            time_labels = {0: '3mo', 1: '1d', 2: '2d', 3: '1mo', 4: '6mo', 5: '5d', 6: '1y', 7: 'ytd'}

            # Predict intent, price type, and time period
            predicted_intent = predict_class(query, intent_model, intent_tokenizer, intent_labels)
            predicted_price_type = predict_class(query, price_model, price_tokenizer, price_labels)
            predicted_time_period = time_period or predict_class(query, time_model, time_tokenizer, time_labels)

            # Handle specific date queries as price_inquiry for volume and prices
            if predicted_intent == "price_inquiry" or (predicted_intent == "stock_trend" and specific_date):
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period, specific_date=specific_date)
                    if stock_data is not None:
                        date_display = specific_date.strftime('%B %d, %Y') if specific_date else "the specified period"
                        print(f"Answer: The {predicted_price_type} of {symbol} on {date_display} is {stock_data}.")
                    else:
                        print(f"Answer: No data available for {symbol} on {date_display}.")
                return

            # Handle stock trend without a specific date
            elif predicted_intent == "stock_trend" and not specific_date:
                stock_data_dict = {}
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period, for_trend=True)
                    if stock_data is not None:
                        stock_data_dict[symbol] = stock_data
                    else:
                        print(f"Answer: No trend data available for {symbol}.")

                if stock_data_dict:
                    plot_multiple_trends(stock_data_dict, predicted_price_type, predicted_time_period)
                return

            # Handle stock comparison
            elif predicted_intent == "stock_comparison":
                stock_prices = []
                for symbol in stock_symbols:
                    stock_data = fetch_stock_data(symbol, predicted_price_type, time_period=predicted_time_period)
                    if stock_data is not None:
                        print(f"Answer: The {predicted_price_type} price of {symbol} over the specified period is {stock_data}.")
                        stock_prices.append(stock_data)
                    else:
                        stock_prices.append(None)
                        print(f"Answer: No data available for {symbol} during the specified period.")

                # Ask if the user wants a comparison plot when multiple stocks are involved
                if len(stock_symbols) > 1 and any(stock_prices):
                    visualize_input = input("Would you like to see a comparison plot? (Yes/No): ").strip().lower()
                    if visualize_input == "yes":
                        valid_prices = [price for price in stock_prices if price is not None]
                        valid_symbols = [symbol for symbol, price in zip(stock_symbols, stock_prices) if price is not None]
                        if valid_prices and valid_symbols:
                            plot_comparison(valid_prices, valid_symbols, predicted_price_type)
                        else:
                            print("Answer: Insufficient data to generate a comparison plot.")
                return

            # Handle summary
            elif predicted_intent == "summary":
                for symbol in stock_symbols:
                    summary = fetch_stock_summary(symbol)
                    print(f"Answer: Summary for {symbol}: {summary}")

            else:
                print(f"Answer: Unable to handle the intent '{predicted_intent}' for the query.")

        else:
            print("Answer: Could not find valid stock symbols in the query.")
    else:
        print("Answer: No company names detected in the query.")


# Run the query loop
while True:
    user_query = input("Ask a question (or type 'exit' to quit): ")
    if user_query.lower() == 'exit':
        break
    handle_query(user_query)



