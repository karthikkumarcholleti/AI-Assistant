# -*- coding: utf-8 -*-
"""THE BIG CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1riPU_WZiuYYYduOdqpQvRXHZam2CEXqb
"""

!pip install transformers yfinance spacy matplotlib torch
!python -m spacy download en_core_web_sm

from google.colab import drive
drive.mount('/content/drive')

from transformers import BertTokenizer, BertForSequenceClassification
import torch

intent_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')
intent_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')

price_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
price_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')

time_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')
time_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')

import spacy
import yfinance as yf
import torch
import matplotlib.pyplot as plt
from transformers import BertTokenizer, BertForSequenceClassification

# Define function to predict class labels from the models
def predict_class(query, model, tokenizer, label_map):
    inputs = tokenizer(query, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)

    predicted_class = torch.argmax(outputs.logits, dim=1).item()

    if predicted_class in label_map:
        return label_map[predicted_class]
    else:
        print(f"Error: Predicted class {predicted_class} not found in label map")
        return None

# Load spaCy NER model
nlp = spacy.load("en_core_web_sm")

# Function to extract stock symbols (manually override certain companies)
def get_stock_symbol(company_name):
    try:
        ticker = yf.Ticker(company_name)
        symbol = ticker.ticker
        if not ticker.history(period="1d").empty:
            return symbol
        else:
            return None
    except Exception as e:
        return None

def extract_company_names(query):
    doc = nlp(query)
    companies = [ent.text for ent in doc.ents if ent.label_ == "ORG"]
    manual_corrections = {
        "Tesla": "TSLA",
        "Amazon": "AMZN",
        "Microsoft": "MSFT",
        "Google": "GOOGL",
        "Facebook": "META",
        "Apple": "AAPL"
    }
    return [manual_corrections.get(company, company) for company in companies]

def fetch_stock_data(stock_symbol, price_type, time_period, for_trend=False):
    stock = yf.Ticker(stock_symbol)
    historical_data = stock.history(period=time_period)

    if not historical_data.empty:
        if for_trend:
            return historical_data['Close']
            if price_type == "open":
                return historical_data['Open'].values[0]
            elif price_type == "close":
                return historical_data['Close'].values[-1]
            elif price_type == "high":
                return historical_data['High'].max()
            elif price_type == "low":
                return historical_data['Low'].min()
            elif price_type == "volume":
                return historical_data['Volume'].sum()
            elif price_type == "current":
                return historical_data['Close'].values[-1]
            else:
                return None
    else:
        return None

#bar graph for stock comparison
def plot_comparison(stock_data, stock_symbols, price_type):
    plt.figure(figsize=(10, 6))
    plt.bar(stock_symbols, stock_data)
    plt.title(f"Stock {price_type.capitalize()} Comparison")
    plt.ylabel(f"{price_type.capitalize()} Price")
    plt.xlabel("Stocks")
    plt.show()

def handle_query(query):
    company_names = extract_company_names(query)

    if company_names:
        stock_symbols = [get_stock_symbol(company) for company in company_names]

        if stock_symbols:
            # Load the fine-tuned models and tokenizers
            intent_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')
            intent_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')

            price_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
            price_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')

            time_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')
            time_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')


            intent_labels = {0: 'price_inquiry', 1: 'stock_comparison', 2: 'stock_trend'}
            price_labels = {0: 'low', 1: 'open', 2: 'high', 3: 'close', 4: 'volume', 5: 'current'}
            time_labels = {0: '3mo', 1: '1d', 2: '2d', 3: '1mo', 4: '6mo', 5: '5d', 6:'1y', 7: 'ytd'}

            # Predict Intent, Price Type, and Time Period
            predicted_intent = predict_class(query, intent_model, intent_tokenizer, intent_labels)
            predicted_price_type = predict_class(query, price_model, price_tokenizer, price_labels)
            predicted_time_period = predict_class(query, time_model, time_tokenizer, time_labels)


            if predicted_intent == "price_inquiry":
                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period)
                if stock_data is not None:
                    print(f"The {predicted_price_type} price of {stock_symbols[0]} is {stock_data}")
                else:
                    print(f"No data available for {stock_symbols[0]} during the specified time period.")

            elif predicted_intent == "stock_comparison":
                stock_prices = [fetch_stock_data(symbol, predicted_price_type, predicted_time_period) for symbol in stock_symbols]
                if all(stock_prices):
                    print(f"Comparison: {stock_prices}")
                    plot_comparison(stock_prices, stock_symbols, predicted_price_type)
                else:
                    print("Error: Could not find stock symbols for comparison.")
            elif predicted_intent == "stock_trend":
                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period, for_trend=True)
                if stock_data is not None:
                    stock_data.plot(title=f"{stock_symbols[0]} {predicted_price_type.capitalize()} Trend", ylabel=f"{predicted_price_type.capitalize()} Price")
                    plt.show()
                else:
                    print(f"No data available to plot for {stock_symbols[0]}.")
        else:
            print(f"Could not find valid stock symbols for {company_names}")
    else:
        print("No company name detected in the query.")


while True:
    user_query = input("Enter your query (or type 'exit' to quit): ")
    if user_query.lower() == 'exit':
        break
    handle_query(user_query)

import spacy
import yfinance as yf
import torch
import matplotlib.pyplot as plt
from transformers import BertTokenizer, BertForSequenceClassification


def predict_class(query, model, tokenizer, label_map):
    inputs = tokenizer(query, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)

    predicted_class = torch.argmax(outputs.logits, dim=1).item()

    if predicted_class in label_map:
        return label_map[predicted_class]
    else:
        print(f"Error: Predicted class {predicted_class} not found in label map")
        return None

# spaCy NER model
nlp = spacy.load("en_core_web_sm")

# Function to extract stock symbols
def get_stock_symbol(company_name):
    try:
        ticker = yf.Ticker(company_name)
        symbol = ticker.ticker
        if not ticker.history(period="1d").empty:
            return symbol
        else:
            return None
    except Exception as e:
        return None

def extract_company_names(query):
    doc = nlp(query)
    companies = [ent.text for ent in doc.ents if ent.label_ == "ORG"]
    manual_corrections = {
        "Tesla": "TSLA",
        "Amazon": "AMZN",
        "Microsoft": "MSFT",
        "Google": "GOOGL",
        "Facebook": "META",
        "Apple": "AAPL"
    }
    return [manual_corrections.get(company, company) for company in companies]

def fetch_stock_data(stock_symbol, price_type, time_period):
    stock = yf.Ticker(stock_symbol)
    historical_data = stock.history(period=time_period)

    if not historical_data.empty:
        if price_type == "open":
            return historical_data['Open'].values[0]
        elif price_type == "close":
            return historical_data['Close'].values[-1]
        elif price_type == "high":
            return historical_data['High'].max()
        elif price_type == "low":
            return historical_data['Low'].min()
        elif price_type == "volume":
            return historical_data['Volume'].sum()
        elif price_type == "current":
            return historical_data['Close'].values[-1]
        else:
            return None
    else:
        return None


# bar graph for stock comparison
def plot_comparison(stock_data, stock_symbols, price_type):
    plt.figure(figsize=(10, 6))
    plt.bar(stock_symbols, stock_data)
    plt.title(f"Stock {price_type.capitalize()} Comparison")
    plt.ylabel(f"{price_type.capitalize()} Price")
    plt.xlabel("Stocks")
    plt.show()

def handle_query(query):
    company_names = extract_company_names(query)

    if company_names:
        stock_symbols = [get_stock_symbol(name) for name in company_names]

        if all(stock_symbols):
            print(f"Identified stock symbols: {stock_symbols}")

            # Load the fine-tuned models and tokenizers
            intent_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')
            intent_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')

            price_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
            price_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')

            time_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')
            time_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')


            intent_labels = {0: 'price_inquiry', 1: 'stock_comparison', 2: 'stock_trend'}
            price_labels = {0: 'low', 1: 'open', 2: 'high', 3: 'close', 4: 'volume', 5: 'current'}
            time_labels = {0: '3mo', 1: '1d', 2: '2d', 3: '1mo', 4: '6mo', 5: '5d', 6:'1y', 7: 'ytd'}

            # Predict Intent, Price Type, and Time Period
            predicted_intent = predict_class(query, intent_model, intent_tokenizer, intent_labels)
            predicted_price_type = predict_class(query, price_model, price_tokenizer, price_labels)
            predicted_time_period = predict_class(query, time_model, time_tokenizer, time_labels)

            print(f"Predicted Intent: {predicted_intent}")
            print(f"Predicted Price Type: {predicted_price_type}")
            print(f"Predicted Time Period: {predicted_time_period}")


            if predicted_intent == "stock_comparison":
                stock_prices = [fetch_stock_data(symbol, predicted_price_type, predicted_time_period) for symbol in stock_symbols]
                if all(stock_prices):
                    for i, symbol in enumerate(stock_symbols):
                        print(f"The {predicted_price_type} price of {symbol.upper()} is {stock_prices[i]}")
                else:
                    print("Error: Could not retrieve data for one or more stocks.")

            elif predicted_intent == "price_inquiry":
                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period)
                if stock_data is not None:
                    print(f"The {predicted_price_type} price of {stock_symbols[0]} is {stock_data}")
                else:
                    print(f"No data available for {stock_symbols[0]} during the specified time period.")

            elif predicted_intent == "stock_trend":
                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period)
                if stock_data is not None:
                    stock_data.plot(title=f"{stock_symbols[0]} {predicted_price_type.capitalize()} Trend", ylabel=f"{predicted_price_type.capitalize()} Price")
                    plt.show()
                else:
                    print(f"No data available to plot for {stock_symbols[0]}.")
        else:
            print(f"Could not find valid stock symbols for: {company_names}")
    else:
        print("No company names detected in the query.")



while True:
    user_query = input("Enter your query (or type 'exit' to quit): ")
    if user_query.lower() == 'exit':
        break
    handle_query(user_query)

import spacy
import yfinance as yf
import torch
import matplotlib.pyplot as plt
from transformers import BertTokenizer, BertForSequenceClassification


def predict_class(query, model, tokenizer, label_map):
    inputs = tokenizer(query, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)

    predicted_class = torch.argmax(outputs.logits, dim=1).item()
    if predicted_class in label_map:
        return label_map[predicted_class]
    else:
        print(f"Error: Predicted class {predicted_class} not found in label map")
        return None


nlp = spacy.load("en_core_web_sm")


def get_stock_symbol(company_name):
    try:
        ticker = yf.Ticker(company_name)
        symbol = ticker.ticker
        if not ticker.history(period="1d").empty:
            return symbol
        else:
            print(f"Error: No data found for symbol {symbol}. The stock might be delisted.")
            return None
    except Exception as e:
        return None

def extract_company_names(query):
    doc = nlp(query)
    companies = [ent.text for ent in doc.ents if ent.label_ == "ORG"]
    manual_corrections = {
        "Tesla": "TSLA",
        "Amazon": "AMZN",
        "Microsoft": "MSFT",
        "Google": "GOOGL",
        "Facebook": "META",
        "Apple": "AAPL"
    }

    return [manual_corrections.get(company, company) for company in companies]


def fetch_stock_data(stock_symbol, price_type, time_period, for_trend=False):
    stock = yf.Ticker(stock_symbol)
    historical_data = stock.history(period=time_period)

    if not historical_data.empty:
        if for_trend:

            if price_type in ['open', 'close', 'high', 'low', 'volume']:
                return historical_data[price_type.capitalize()]
            else:
                return historical_data['Close']  # Fallback to 'Close' for trends
        else:
            if price_type == "open":
                return historical_data['Open'].iloc[0]
            elif price_type == "close":
                return historical_data['Close'].iloc[-1]
            elif price_type == "high":
                return historical_data['High'].max()
            elif price_type == "low":
                return historical_data['Low'].min()
            elif price_type == "volume":
                return historical_data['Volume'].sum()
            elif price_type == "current":
                return historical_data['Close'].iloc[-1]
    else:
        return None


def handle_query(query):
    company_names = extract_company_names(query)

    if company_names:
        stock_symbols = [get_stock_symbol(company) for company in company_names]

        if all(stock_symbols):
            print(f"Identified stock symbols: {stock_symbols}")

            # Load the fine-tuned models and tokenizers
            intent_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')
            intent_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_intent_model1')

            price_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')
            price_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_price_type_model')

            time_model = BertForSequenceClassification.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')
            time_tokenizer = BertTokenizer.from_pretrained('/content/drive/MyDrive/fine_tuned_time_period_model')

            # Map intents, price types, and time periods
            intent_labels = {0: 'price_inquiry', 1: 'stock_comparison', 2: 'stock_trend'}
            price_labels = {0: 'low', 1: 'open', 2: 'high', 3: 'close', 4: 'volume', 5: 'current'}
            time_labels = {0: '3mo', 1: '1d', 2: '2d', 3: '1mo', 4: '6mo', 5: '5d', 6:'1y', 7: 'ytd'}

            # Predict Intent, Price Type, and Time Period
            predicted_intent = predict_class(query, intent_model, intent_tokenizer, intent_labels)
            predicted_price_type = predict_class(query, price_model, price_tokenizer, price_labels)
            predicted_time_period = predict_class(query, time_model, time_tokenizer, time_labels)

            print(f"Predicted Intent: {predicted_intent}")
            print(f"Predicted Price Type: {predicted_price_type}")
            print(f"Predicted Time Period: {predicted_time_period}")


            if predicted_intent == "price_inquiry":
                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period)
                if stock_data is not None:
                    print(f"The {predicted_price_type} price of {stock_symbols[0]} is {stock_data}")
                else:
                    print(f"No data available for {stock_symbols[0]} during the specified time period.")

            elif predicted_intent == "stock_comparison":
                stock_prices = [fetch_stock_data(symbol, predicted_price_type, predicted_time_period) for symbol in stock_symbols]
                print(f"Comparison: {stock_prices}")

                visualize_input = input("Do you want to visualize this comparison in a graph? (Yes/No): ").strip().lower()
                if visualize_input == "yes":
                    plot_comparison(stock_prices, stock_symbols, predicted_price_type)
                else:
                    print("Comparison complete. No graph requested.")

            elif predicted_intent == "stock_trend":

                stock_data = fetch_stock_data(stock_symbols[0], predicted_price_type, predicted_time_period, for_trend=True)
                if stock_data is not None:
                    stock_data.plot(title=f"{stock_symbols[0]} {predicted_price_type.capitalize()} Trend", ylabel=f"{predicted_price_type.capitalize()} Price")
                    plt.show()
                else:
                    print(f"No trend data available for {stock_symbols[0]}.")
        else:
            print(f"Could not find valid stock symbols for {company_names}")
    else:
        print("No company names detected in the query.")


while True:
    user_query = input("Enter your query (or type 'exit' to quit): ")
    if user_query.lower() == 'exit':
        break
    handle_query(user_query)











